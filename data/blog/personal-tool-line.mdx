---
title: เมื่ออยากมี Tools ส่วนตัวใช้ในชีวิตประจำวันผ่าน LINE
date: "2023-09-04"
tags: ["node", "line","linebot"]
draft: false
summary: ""
layout: PostSimple
featureImage: "/static/images/blog/personal-tool-line/cover.png"
---

<center>![Cover](/static/images/blog/personal-tool-line/cover.png)</center>
<center className="text-xs">
  ขอบคุณรูปภาพจาก
  [https://bs-uploads.toptal.io](https://bs-uploads.toptal.io/blackfish-uploads/components/seo/content/og_image_file/og_image/1020542/chatbot-fails-b7e2373d46845ca189f736687c435770.png)
</center>

จุดเริ่มต้นทั้งหมดเริ่มจากผมได้ไปดู Video ของคุณ [dtinth](https://dt.in.th/) ชื่อ Video ว่า [Let’s build a personal assistant bot and level up your coding skills!](https://youtu.be/IdFX7nwD744)
เมื่อผมดูจนจบ ผมสนใจมากๆ(ค่อนข้างจะตื่นเต้นกับอะไรที่ไม่เคยทำ) และผมได้เริ่มทำมันทันที !!

## ทำอะไรไปบ้าง ?

<center>![Cover](/static/images/blog/personal-tool-line/maping.png)</center>

หลักๆแล้วแบ่งออกเป็น 2 Process

1. **LINE** - เป็นส่วนที่ผมเองใช้พูดคุยกับ Bot ชื่อว่า [Janalyze](#janalyze)
2. **Custom Service** - เป็นส่วนของการทำงานฝั่งหลังบ้านที่จะรับข้อมูลจาก LINE แล้วเอามาประมวลผลตาม Logic มีการแยกการทำงานระหว่าง Text และ Image ผมตั้งชื่อว่า [Jasistant](#jasistant)

<br />

<center>. . .</center>

<br />

### Janalyze

1. เข้าไปที่ [LINE Developers](https://developers.line.biz/en/) แล้ว Login จะเจอกับหน้านี้

![Cover](/static/images/blog/personal-tool-line/console.png)

<br />

2. สร้าง Providers (จากรูปข้อที่ 1 คลิก **"Create"**) ใส่ชื่ออะไรก็ได้

![Cover](/static/images/blog/personal-tool-line/create-pro.png)

<br />

3. เลือก **"Create a Messaging API channel"**

![Cover](/static/images/blog/personal-tool-line/choose.png)

<br />

4. กรอกข้อมูลต่างๆให้ครบ แล้ว **"Create"**

![Cover](/static/images/blog/personal-tool-line/channel-create.png)

<br />

5. มาที่ **"Messaging API"** แล้วเลื่อนลงไปที่ **"Webhook settings"** ทำการแก้ไข **"Webhook URL"**
   ต้องเป็น HTTPS เท่านั้น เมื่อส่งข้อความหา Bot จะมาเรียก URL ที่เรากรอกไปเสมอ

![Cover](/static/images/blog/personal-tool-line/webhook-url.png)

<br />

6. สามารถ Scan QR Code เพิ่มเพื่อน Bot ได้เลย เสร็จสิ้นการสร้าง Line Bot 

![Cover](/static/images/blog/personal-tool-line/qr.png)

<br />

<center>. . .</center>

<br />

### Jasistant

ตอนเริ่มแรกผมยังไม่มี URL ที่เป็น HTTPS และผมอยากรีบทดสอบแบบเร็วๆ ผมเลยไปใช้ [Glitch](https://glitch.com/)
เป็น IDE บน Browser สามารถเอา URL ขวาบนมาใช้ได้เลย เพื่อทดสอบว่า Line Bot สามารถเชื่อมต่อกับ Service หลังบ้านได้จริงๆ
แต่สำหรับเริ่มต้นเท่านั้นนะ ควรเอามาขึ้น Github แล้วหา Host ให้มันอยู่ดีๆ

![Cover](/static/images/blog/personal-tool-line/glitch.png)

*จากรูปเราแค่ใส่ Log อะไปก็ได้ใน `/webhook` แล้วลองส่งข้อความหา Bot*

พอผมเริ่มเข้าใจและวางโครงได้แล้ว เลยมาทำเป็น Custom Service และหา Host ให้มันอยู่ โดยมี Tech Stack ประมาณนี้

- [Node.js](https://nodejs.org/en) - ใช้เป็นภาษาหลักในการทำ Backend Service
  - [promptpay-qr](https://github.com/dtinth/promptpay-qr) (NPM Package) -  ใช้สร้าง QR Code แบบพร้อมเพย์
  - [tweetnacl-sealedbox-js](https://www.npmjs.com/package/tweetnacl-sealedbox-js) (NPM Package) - ส่งหรือรับข้อมูลแบบเข้ารหัส
- [Express.js](https://expressjs.com/) - ใช้เป็น Framework ให้กับ Node.js
- [Vercel](https://vercel.com/) - ใช้เป็น Hosting เพราะมันฟรีและ Custom ง่ายมาก
- [Google Cloud Storage](https://cloud.google.com/storage) (เก็บรูปภาพ) - เมื่อเราต้องการส่งรูปภาพและให้ Bot ประมวลผลอะไรสักอย่างจะต้องมีที่เก็บรูปภาพ
- [Google Cloud Vision AI](https://cloud.google.com/vision) (ดึงข้อความจากรูปภาพ) - เป็น AI สำหรับดึงข้อความจากรูปภาพ
- [Airtable](https://www.airtable.com/) (บันทักรายจ่าย) - เป็น Database แบบง่ายๆ ที่เอาไว้เก็บข้อมมูลรายรับ รายจ่าย 
สามารถแก้ไขข้อมูลต่างๆผ่าน App ในมือถือได้เลยและ Export เป็น Excel ได้ด้วย ใช้งานง่ายพอสมควรแค่เข้าไปสมัครแล้วล็อคอิน สร้าง Workspace ได้เลย

> [Source Code](https://github.com/Janescience/jasistant)

{/* <br />

<center>. . .</center>

<br />

### Structure

![Cover](/static/images/blog/personal-tool-line/structure.png)


<br />

<center>. . .</center>

<br />

### Server properties

```js:server.js
// Import NPM
const express = require('express');
const bodyParser = require('body-parser')
const path = require("path");
const errorHandler  = require('./src/middlewares/error-handler');
const dotenv = require('dotenv');
dotenv.config();

// Initialize express app 
const app = express();
app.use(express.json({limit:'50mb'}))
app.use(express.urlencoded({limit: '50mb', extended:true }))
app.use(express.static(path.join(__dirname, '/public')))
app.use(bodyParser.text())

// Routes setup  
require('./src/routes/webhook.routes')(app);

// Basic route
app.get(["/","/index.html"],(req,res) => {
  res.sendFile(path.join(__dirname, 'views','index.html'));
})

// Not found route
app.all("*", (req,res) => {
  res.status(404);
  if(req.accepts('html')){
    res.sendFile(path.join(__dirname, 'views','404.html'));
  } else if (req.accepts('json')) {
    res.json({error : "404 Not Found"});
  }else {
    res.type('txt').send('404 Not Found')
  }
})

//Error handler
app.use(errorHandler)

//App started
app.listen(process.env.PORT, () => {
  console.log("Server is running on port : ",process.env.PORT);
})
```

#### Comments

- ***Import NPM*** - เป็นส่วนที่บอกว่า Code หน้านี้เราจะใช้ NPM อะไรบ้าง ก็ให้ Import เข้ามาและเราต้อง Install ผ่าน `npm` ก่อนด้วย
  ```bash
  npm i express body-parser dotenv
  ```
- ***Initialize Express App*** - เรียกใช้เฟรมเวิร์ค Express และตั้งค่าต่างๆ ไม่ว่าจะเป็น Limit การรับส่งข้อมูล หรือ Path ของ Static file
- ***Routes Setup*** - บอกว่า App มี Routes อะไรบ้าง โดยในไฟล์จะเป็นการกำหนด HTTP Method แยก Path ตามไฟล์ เมื่อเรียก URL มาที่ `/webhook` จะวิ่งเข้า `webhook.controller`
  ```js:webhook.routes.js
  const controller = require("../controllers/webhook.controller");
  const { logger } = require("../middlewares/log-events");
  module.exports = function(app) {
    app.use(function(req, res, next) {
      res.header(
        "Access-Control-Allow-Headers",
        "x-access-token, Origin, Content-Type, Accept"
      );
      next();
    });

    app.post('/webhook',[logger],controller.webhook);
  };
  ```
  
- ***Basic Route*** - กำหนด Default Path ถ้าเข้าด้วย URL `/` หรือ `/index.html` จะให้ทำอะไรบ้างหรือ Redirect ไปไฟล์ไหน 
  ```html:index.html
  <div id="main">
    <div class="fof">
        <h1>Welcome Jasistant Engine</h1>
    </div>
  </div>
  ```
- ***Not Found Route*** - กำหนดว่าถ้ามีการเข้า URL อะไรก็ตามที่ไม่มีอยู่ใน App จะให้แสดงเป็นอะไร ของผมให้แสดงหน้า `404.html`
  ```html:404.html
  <div id="main">
    <div class="fof">
        <h1>Error 404</h1>
    </div>
  </div>
  ```
- ***Error Handler*** - เมื่อมี Error จะให้ทำตาม Process ในไฟล์ `/src/middlewares/error-handler`
  ```js:error-handler.js
  const { logEvents } = require('./log-events');

  const errorHandler = (err,req,res,next) => {
      logEvents(`${err.name} : ${err.message}`);
      res.status(500).send(err);
  }

  module.exports = errorHandler;
  ```
  - **errorHandler** - ทุกครั้งที่เกิด Error จะให้แสดง Log ออกมาผ่าน `logEvent` และ Return กลับไปด้วย Error code = 500 เสมอ
  ```js:log-event.js
  const { format } = require('date-fns');
  const { v4:uuid } = require('uuid');

  const logEvents = async (message) => {
      const dateTime = `${format(new Date(),'yyyyMMdd\tHH:mm:ss')}`;
      const logItem = `${dateTime}\t${uuid()}\t${message}\n`;
      console.log(logItem)
  }

  const logger = (req,res,next) => {
      if(req.body){
          console.log(`${req.method} ${req.path} ${JSON.stringify(req.body)}`);
      }else{
          console.log(`${req.method} ${req.path}`);
      }
      next();
  }

  module.exports = { logger , logEvents};
  ```
  - **logEvents** - ที่เราทำแบบนี้เพื่อกำหนด Format ของ Log และเลือกได้จะเรียกใช้ตรงไหน
  - **logger** - สำหรับเอาไว้ Log ทุกครั้งที่มีการ Request เข้ามา และเราเลือกจะใส่หรือไม่ใส่ก็ได้แต่ล่ะ Path ในไฟล์ `.routes.js`
- ***App Started*** - กำหนดได้ว่าให้ Running ที่ PORT อะไร ผมกำหนดไว้ใน `process.env.PORT` 
และในฟังก์ชัน `listen` กำหนดได้ว่าให้ทำอะไรบ้างตอน Start project ผมให้แสดง Log ออกมาว่า Run ที่ PORT อะไร
  ```js:.env
  PORT=3000
  ```

<br />

<center>. . .</center>

<br />

### Config

```js:/config/line.config.js
const dotenv = require('dotenv');
dotenv.config();

const config = () => {
    return { 
        channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN,
        channelSecret: process.env.LINE_CHANNEL_SECRET
    }
}

module.exports = config
```

- ใช้ `dotenv` เพื่อให้เข้าถึงตัวแปรในไฟล์ `.env` ได้
- *LINE_CHANNEL_ACCESS_TOKEN* เอาค่ามาจาก **Messaging API** แล้วเลื่อนไปข้างล่างสุดดูที่หัวข้อ **Channel access token**
- *LINE_CHANNEL_SECRET* เอาค่ามาจาก **Basic settings** แล้วไปที่หัวข้อ **Channel secret**

<br />

<center>. . .</center>

<br />

### Service

```js:/services/message.service.js

const expenseTracking = require("../modules/expense-tracking.module")
const qrcodePromptpay = require("../modules/qrcode-promptpay.module")

const category = {
  t: "transportation",
  f: "food",
  e: "electronic",
  d: "drinks",
  c: "clothes",
  a: "alcohal",
  g: "game",
  h: "health",
  m: "miscellaneous",
  o: "occasion",
  l: "lodging"
}

const messageService = async (message) =>{
    message = message.trim()
    let match
    
    if (match = message.match(/^([\d.]+|[ivxlcdm]+)([tfedcaghmol])([ \w]+|)$/i)) {
      const m = match
      
      const enteredAmount = +m[1]
      const amount = enteredAmount.toFixed(2)
      const ctg = category[m[2].toLowerCase()]
      const name = m[3] ? m[3] : ""

      return await expenseTracking(null,name,amount, ctg)
    }else if(match = message.match(/^(expctg)$/i)){
      return {message :  JSON.stringify(category,null,4) }
    }else if(match = message.match(/^(qr)([\d.]+)$/i)){
      const m = match
      const amount = Number(match[2])
      return await qrcodePromptpay(amount)
    }
}

module.exports = messageService;
```

<br />

<center>. . .</center>

<br />

### Utilities

#### Line
```js:/utilities/line.utility.js
const toMessages = (data) => {
  if (!data) data = "Data reply is undefined..."
  if (typeof data === "string") data = [{ type: "text", text: data }]
  return data
}
  
const createBubble = (
  title,
  text,
  {
    headerBackground = "#353433",
    headerColor = "#d7fc70",
    textSize = "xl",
    altText = String(text),
    footer
  } = {}
) => {
  const data = {
    type: "bubble",
    styles: {
      header: { backgroundColor: headerBackground }
    },
    header: {
      type: "box",
      layout: "vertical",
      contents: [
        { type: "text", text: title, color: headerColor, weight: "bold" }
      ]
    },
    body:
      typeof text === "string"
        ? {
            type: "box",
            layout: "vertical",
            contents: [{ type: "text", text: text, wrap: true, size: textSize }]
          }
        : text
  }
  if (footer) {
    data.styles.footer = { backgroundColor: "#e9e8e7" }
    data.footer =
      typeof footer === "string"
        ? {
            type: "box",
            layout: "vertical",
            contents: [
              {
                type: "text",
                text: footer,
                wrap: true,
                size: "sm",
                color: "#8b8685"
              }
            ]
          }
        : footer
  }
  return {
    type: "flex",
    altText: truncate(`[${title}] ${altText}`, 400),
    contents: data
  }
}

const  truncate = (text, maxLength) => {
  return text.length + 5 > maxLength
    ? text.substr(0, maxLength - 5) + "…"
    : text
}

const readAsBuffer = (stream) => {
  return new Promise((resolve, reject) => {
    stream.on("error", e => {
      reject(e)
    })
    const bufs = []
    stream.on("end", () => {
      resolve(Buffer.concat(bufs))
    })
    stream.on("data", buf => {
      bufs.push(buf)
    })
  })
}
  
const utility = {
  toMessages,
  createBubble,
  readAsBuffer
};

module.exports = utility;
  
```


- **toMessage** - ใช้สำหรับส่งค่ากลับไปใน Line(Bot ตอบเรา) แบบเป็นข้อความธรรมดา โดยมีการตรวจสอบด้วยว่าจะต้องเป็น String เท่านั้น 
- **createBubble** - เป็นการตอบกลับแบบ Flex Message ที่จะไม่ใช่ข้อความธรรมดา อาจจะมีรูปหรือปุ่มให้กดได้ จัดแบบฟอร์มและตำแหน่งข้อความตามต้องการ
โดยของผมจะสร้าง Layout ไว้หมดแล้วและรับเอาแค่บางตัวแปร อ่านเพิ่มเติมได้ที่ [Flex Message](https://developers.line.biz/en/docs/messaging-api/using-flex-messages/) 
- **truncate** - ในกรณีที่ข้อความยาวเกินที่กำหนดจะให้แสดงเป็น *...*
- **readAsBuffer** - ใช้สำหรับรูปภาพเปลี่ยน Content เป็น Buffer เพื่อนำไปส่งเข้า Cloud อีกที


<br/>

#### Storage

```js:/utilities/storage.utility.js
const { Storage } = require("@google-cloud/storage")
const { nanoid } = require("nanoid")

const storage = new Storage(
  {
    projectId: process.env.GCS_PROJECT_ID,
    scopes: 'https://www.googleapis.com/auth/cloud-platform',
    credentials: {
      client_email: process.env.GCS_EMAIL,
      private_key: process.env.GCS_PRIVATE_KEY
    }
  }
);

const putBlob = async (buffer, extension) => {
  const blobName = nanoid() + extension
  await storage
    .bucket("tmpblobimg")
    .file(blobName)
    .save(buffer)
  return blobName
}

const getBlob = async (blobName) => {
  const response = await storage
    .bucket("tmpblobimg")
    .file(blobName)
    .download()
  return response[0]
}

const deleteBlob = async (blobName) => {
  await storage
    .bucket("tmpblobimg")
    .file(blobName)
    .delete();
}

const getBlobUrl = async (blobName) => {
  const result = await storage
    .bucket("tmpblobimg")
    .file(blobName)
    .getSignedUrl({
      action: "read",
      expires: new Date(Date.now() + 86400e3),
      version: "v4",
      virtualHostedStyle: true
    })
  return result[0]
}

const cloudStorage = {
  putBlob,
  getBlob,
  deleteBlob,
  getBlobUrl
};

module.exports = cloudStorage;

```

- **storage** - เป็นการ Authorization storage ใน Cloud ด้วยการใช้ Project ID , Email และ Private Key


<br />

<center>. . .</center>

<br />

### Modules

#### Expense Tracking
```js:/modules/expense-tracking.module.js
const Airtable = require("airtable");
const { AirtableRecord } = require("airtable");
const { createBubble } = require("../utilities/line.utility");

const expenseTable = () => {
  return new Airtable({ apiKey: process.env.AIRTABLE_API_KEY })
    .base(process.env.AIRTABLE_EXPENSE_BASE)
    .table("Expense Records");
};

const expenseTracking = async (time,name,amount, category) => {
  const date = time ? time : new Date();
  // Airtable
  const recorded = await expenseTable().create(
    {
      Name: name.trim(),
      Date: date,
      Category: category,
      Amount: amount,
    },
    { typecast: true }
  );
  const body = {
    type: "box",
    layout: "vertical",
    contents: [
      {
        type: "text",
        text: "฿" + amount,
        size: "xxl",
        weight: "bold",
      },
      {
        type: "text",
        text: `${category}${name ? "\n" + name.trim() : ""}`,
        wrap: true,
      },
    ],
    action: {
      type: "uri",
      label: "Open Airtable",
      uri: process.env.AIRTABLE_EXPENSE_URI + "/" + recorded.getId(),
    },
  };
  const footer = await summary();
  const bubble = createBubble("Expense Tracking", body, {
    headerColor: "#f7f7f2",
    footer: {
      type: "box",
      layout: "horizontal",
      spacing: "sm",
      contents: footer.map(([label, text]) => ({
        type: "box",
        layout: "vertical",
        contents: [
          {
            type: "text",
            text: label,
            color: "#8b8685",
            size: "xs",
            align: "end",
          },
          {
            type: "text",
            text: text,
            color: "#8b8685",
            size: "sm",
            align: "end",
          },
        ],
      })),
      action: {
        type: "uri",
        label: "Open Airtable",
        uri: process.env.AIRTABLE_EXPENSE_URI,
      },
    },
  });
  return {message:bubble};
};

const summary = async () => {
  const date = new Date().toJSON().split("T")[0];
  const tableData = await expenseTable().select().all();
  const normalRecords = tableData.filter((r) => !r.get("Occasional"));
  const records = AirtableRecord;
  const total = (records) => records.map((r) => +r.get("Amount") || 0).reduce((a, b) => a + b, 0);
  const firstDate = normalRecords
    .map((r) => (r.get("Date") ? r.get("Date").split("T")[0] : r.get("Date")))
    .reduce((a, b) => (a < b ? a : b), date);

  const todayUsage = total(
    normalRecords.filter(
      (r) => (r.get("Date") ? r.get("Date").split("T")[0] : r.get("Date")) === date
    )
  );
  const dayNumber = Math.round((Date.parse(date) - Date.parse(firstDate)) / 86400e3) + 1;
  const $ = (v) => `฿${v.toFixed(2)}`;

  return [
    ["Today", $(todayUsage)], //รายจ่ายรวมทั้งหมดของวันนี้
    ["Day", `${dayNumber}`], //รวมแล้วมีการบันทึกรายจ่ายทั้งหมดกี่วัน
  ];
};

module.exports = expenseTracking;

```
- **expenseTable** - เป็นการบอกว่าเราใช้ Airtable อันไหนและ Table ชื่อว่าอะไร เชื่อมต่อด้วย APIKEY และ BASE ID ส่วนตรงชื่อ Table ถ้าเรายังไม่ได้สร้าง
มันก็จะสร้างให้อัตโนมัติ
  - **AIRTABLE_API_KEY** (APIKEY) - เข้าไปดูข้อมูลที่ [APIKEY](https://airtable.com/create/apikey)
  - **AIRTABLE_EXPENSE_BASE** (BASE ID) - เป็น Base ID เพื่อบอกว่าเราต่อกับ Base อันไหน ให้ดูจาก URL โดยเอาค่ามาจาก หลัง `.com/` เช่น 
  https://airtable.com/app1brOBAd2BLsotU/tbltpKT3ZVDRoo8zG/viwvm85L6NKZcvifX?blocks=hide ก็ให้เอาค่า **app1brOBAd2BLsotU** มาใช้
- **expenseTracking** - เตรียม Flex Message ไม่ว่าจะเป็น body, footer, action 
- **summary** - เป็นการคำนวณรายจ่ายรวมของแต่ล่ะวัน และคำนวณว่าเราบันทึกรายจ่ายมาแล้วกี่วัน

<br/>

#### QRCode Promptpay

```js:/modules/qrcode-promptpay.module.js
const qrcode = require('qrcode')
const generatePayload = require('promptpay-qr')
const { putBlob,getBlobUrl } = require('../utilities/storage.utility')

const generateQrcode = async (amount) => {

  const mobileNumber = '080-608-XXXX'
  const payload = generatePayload(mobileNumber, { amount })
  
  const bufferImage = await qrcode.toBuffer(payload, {
      type: 'jpg',
      errorCorrectionLevel: 'H',
  });

  const blobName = await putBlob(bufferImage, ".jpg")
  const blobUrl = await getBlobUrl(blobName)

  const message = 
  [
    {
      type: 'image',
      originalContentUrl: blobUrl,
      previewImageUrl: blobUrl
    },
    {
      type: "text",
      text: `${amount} บาท`,
    }
  ]
  
  return {
      message: message,
      blobName : blobName
    }
}

module.exports = generateQrcode;

```

- **qrcode** (NPM Packages) - สำหรับแปลง Payload เป็นรูป QRCode
- **promptpay-qr** (NPM Packages) - สำหรับสร้าง Payload ที่เอาไว้สร้าง QRCode จากเบอร์โทรศัพท์และจำนวนเงิน
- **generateQrcode** - 
--- */}

<br />

<center>. . .</center>

<br />

## การใช้งาน

1. **Expense Record** - แน่นอนว่าทุกวันนี้มีแอปบันทึกรายรับ-รายจ่ายเต็มไปหมด แต่การบันทึกแต่ล่ะรายการนั้น
   ต้องทำอย่างน้อย 2-3 step และมีหลายอย่างที่ต้องกรอก แต่ Line Bot ของผมแค่พิมพ์สั้นๆ เช่น พิมพ์ว่า "60f" เป็นการบอกว่า จ่ายค่าอาหารไป 60 บาทนะ
   และ Bot จะตอบกลับมาโดยสามารถคลิกเข้าไปแก้ไขข้อมูลได้ผ่าน [Airtable](https://www.airtable.com/)

| คำสั่ง "60f"                                           | คำสั่ง "145d startbuck"                                  |
| ------------------------------------------------------ | -------------------------------------------------------- |
| ![60f](/static/images/blog/personal-tool-line/60f.jpg) | ![145d](/static/images/blog/personal-tool-line/145d.jpg) |

| Airtable(Rows)                                                        | Airtable(Detail)                                                          |
| --------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| ![Airtable Rows](/static/images/blog/personal-tool-line/airtable.jpg) | ![Airtable Detail](/static/images/blog/personal-tool-line/air-detail.jpg) |

<br />

<center>. . .</center>

<br />

2. **QR Code Promptpay** - ทำได้ง่ายๆ ถ้าอยากได้ QR ที่เป็น 100 บาท ก็พิมพ์ว่า "qr100" ก็จะได้ QR Code ที่ล็อคจำนวนเงินไว้ให้เลย (ลอง Scan ดูได้)
   การทำงานคร่าวๆ คือสร้าง QR Code เป็น Buffer แล้ว Upload ขึ้น Google Cloud Storage ส่งค่ากลับมาเป็น Url และ Reply กลับมาผ่าน Line แสดงเป็นรูปภาพ

![QR Code](/static/images/blog/personal-tool-line/qrcode.png)

<br />

<center>. . .</center>

<br />

3. **Image to Text** - ส่งรูปภาพอะไรไปก็ได้ แล้ว Bot จะตอบกลับมาเป็นข้อความทั้งหมดที่อยู่ในรูปภาพ ความแม่นยำและถูกต้องขึ้นอยู่กับความคมชัดของข้อความในรูปภาพ แต่ถ้าเป็นภาษาไทยประโยคที่ได้จะเว้นเป็นคำๆ
   ไม่ติดกัน ซึ่งผมก็ไม่ทราบว่าเพราะอะไร เพราะการดึงข้อความตรงนี้เราใช้ [Google Cloud Vision AI](https://cloud.google.com/vision)

![QR Code](/static/images/blog/personal-tool-line/imgtotxt1.png)

ซึ่งถ้าเขียนด้วยลายมือ Bot อาจจะอ่านไม่ออกบางคำ จะเห็นตกคำว่า **"เค้าแค่ไม่อยาก"** และคำว่า **"งดรีโพส"** ได้มาเป็น **"งด รีม ส"**

![QR Code](/static/images/blog/personal-tool-line/imgtotxt2.png)

แต่ถ้าเป็นตัวอักษรที่พิมพ์เอาและถ่ายให้ชัดเจน ค่อนข้างจะถูกต้อง 100% นอกจากตัวอักษรนั้นจะเล็กมากๆ
